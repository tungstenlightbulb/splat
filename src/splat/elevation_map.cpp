/** @file elevation_map.cpp
 *
 * File created by Peter Watkins (KE7IST) 8/12/16.
 * Derived from original project code.
 * Splat!
 * @copyright 1997 - 2018 John A. Magliacane (KD2BD) and contributors.
 * See revision control history for contributions.
 * This file is covered by the LICENSE.md file in the root of this project.
 */

#include <vector>
#include <cmath>
#include <string>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <unistd.h>
#include <bzlib.h>
#include "site.h"
#include "splat_run.h"
#include "dem.h"
#include "path.h"
#include "utilities.h"
#include "fontdata.h"
#include "pat_file.h"
#include "lrp.h"
#include "sdf.h"
#include "elevation_map.h"
#include "itwom3.0.h"

using namespace std;

ElevationMap::ElevationMap(Path &path,
                           const SplatRun &sr)
:dem(sr.maxpages, Dem(sr.ippd)), path(path), sr(sr),
min_north(90), max_north(-90), min_west(360), 
max_west(-1), max_elevation(-32768), min_elevation(32768)
{
    for (int i=0; i < sr.maxpages; i++)
    {
        dem[i].min_el=32768;
        dem[i].max_el=-32768;
        dem[i].min_north=90;
        dem[i].max_north=-90;
        dem[i].min_west=360;
        dem[i].max_west=-1;
    }
}

ElevationMap::~ElevationMap()
{

}


int ElevationMap::PutMask(double lat, double lon, int value)
{
    /* Lines, text, markings, and coverage areas are stored in a
     mask that is combined with topology data when topographic
     maps are generated by SPLAT!.  This function sets and resets
     bits in the mask based on the latitude and longitude of the
     area pointed to. */
    
    int	x = 0, y = 0, indx;
    char	found;
    
    for (indx=0, found=0; indx<sr.maxpages && found==0;)
    {
        x=(int)rint(sr.ppd*(lat-dem[indx].min_north));
        y=sr.mpi-(int)rint(sr.ppd*(Utilities::LonDiff(dem[indx].max_west,lon)));
        
        if (x>=0 && x<=sr.mpi && y>=0 && y<=sr.mpi)
            found=1;
        else
            indx++;
    }
    
    if (found)
    {
        dem[indx].mask[x * sr.ippd + y]=value;
        return ((int)dem[indx].mask[x * sr.ippd + y]);
    }
    
    else
        return -1;
}

int ElevationMap::OrMask(double lat, double lon, int value)
{
    /* Lines, text, markings, and coverage areas are stored in a
     mask that is combined with topology data when topographic
     maps are generated by SPLAT!.  This function sets bits in
     the mask based on the latitude and longitude of the area
     pointed to. */
    
    int	x = 0, y = 0, indx;
    bool found = FindMask(lat, lon, x, y, indx);
    
    if (found)
    {
        dem[indx].mask[x * sr.ippd + y]|=value;
        return ((int)dem[indx].mask[x * sr.ippd + y]);
    }
    else
    {
        return -1;
    }
}

int ElevationMap::GetMask(double lat, double lon) const
{
    /* This function returns the mask bits based on the latitude
     and longitude given. */
    
    int	x = 0, y = 0, indx;
    
    return FindMask(lat, lon, x, y, indx) ? ((int)dem[indx].mask[x * sr.ippd + y]) : -1;
}

bool ElevationMap::FindMask(double lat, double lon, int &x, int &y, int &indx) const
{
    /* Finds the x, y, and indx for the given lat and lon */
    bool found = false;
    
    for (indx=0, found=false; indx<sr.maxpages && found==false;)
    {
        x=(int)rint(sr.ppd*(lat-dem[indx].min_north));
        y=sr.mpi-(int)rint(sr.ppd*(Utilities::LonDiff(dem[indx].max_west,lon)));
        
        if (x>=0 && x<=sr.mpi && y>=0 && y<=sr.mpi)
            found = true;
        else
            indx++;
    }
    
    return found;
}

double ElevationMap::GetElevation(const Site &location) const
{
    /* This function returns the elevation (in feet) of any location
     represented by the digital elevation model data in memory.
     Function returns -5000.0 for locations not found in memory. */
    
    char	found;
    int	x = 0, y = 0, indx;
    double	elevation;
    
    for (indx=0, found=0; indx<sr.maxpages && found==0;)
    {
        x=(int)rint(sr.ppd*(location.lat-dem[indx].min_north));
        y=sr.mpi-(int)rint(sr.ppd*(Utilities::LonDiff(dem[indx].max_west,location.lon)));
        
        if (x>=0 && x<=sr.mpi && y>=0 && y<=sr.mpi)
            found=1;
        else
            indx++;
    }
    
    if (found)
        elevation=3.28084*dem[indx].data[x * sr.ippd + y];
    else
        elevation=-5000.0;
    
    return elevation;
}

int ElevationMap::AddElevation(double lat, double lon, double height)
{
    /* This function adds a user-defined terrain feature
     (in meters AGL) to the digital elevation model data
     in memory.  Does nothing and returns 0 for locations
     not found in memory. */
    
    char	found;
    int	x = 0, y = 0, indx;
    
    for (indx=0, found=0; indx<sr.maxpages && found==0;)
    {
        x=(int)rint(sr.ppd*(lat-dem[indx].min_north));
        y=sr.mpi-(int)rint(sr.ppd*(Utilities::LonDiff(dem[indx].max_west,lon)));
        
        if (x>=0 && x<=sr.mpi && y>=0 && y<=sr.mpi)
            found=1;
        else
            indx++;
    }
    
    if (found)
        dem[indx].data[x * sr.ippd + y]+=(short)rint(height);
    
    return found;
}

double ElevationMap::ElevationAngle(const Site &source, const Site &destination) const
{
    /* This function returns the angle of elevation (in degrees)
     of the destination as seen from the source location.
     A positive result represents an angle of elevation (uptilt),
     while a negative result represents an angle of depression
     (downtilt), as referenced to a normal to the center of
     the earth. */
	   
    double a, b, dx;
    
    a=GetElevation(destination)+destination.alt+sr.earthradius;
    b=GetElevation(source)+source.alt+sr.earthradius;
    
    dx=5280.0*source.Distance(destination);
    
    /* Apply the Law of Cosines */
    
    return ((180.0*(acos(((b*b)+(dx*dx)-(a*a))/(2.0*b*dx)))/PI)-90.0);
}

double ElevationMap::ElevationAngle2(const Site &source, const Site &destination, double er) const
{
    /* This function returns the angle of elevation (in degrees)
     of the destination as seen from the source location, UNLESS
     the path between the sites is obstructed, in which case, the
     elevation angle to the first obstruction is returned instead.
     "er" represents the earth radius. */
    
    int	x;
    char	block=0;
    double	source_alt, destination_alt, cos_xmtr_angle,
    cos_test_angle, test_alt, elevation, distance,
    source_alt2, first_obstruction_angle=0.0;
    //	struct	path *temp;
    //
    //	temp=path;
    
    path.ReadPath(source,destination, *this);
    
    distance=5280.0*source.Distance(destination);
    source_alt=er+source.alt+GetElevation(source);
    destination_alt=er+destination.alt+GetElevation(destination);
    source_alt2=source_alt*source_alt;
    
    /* Calculate the cosine of the elevation angle of the
     destination (receiver) as seen by the source (transmitter). */
    
    cos_xmtr_angle=((source_alt2)+(distance*distance)-(destination_alt*destination_alt))/(2.0*source_alt*distance);
    
    /* Test all points in between source and destination locations to
     see if the angle to a topographic feature generates a higher
     elevation angle than that produced by the destination.  Begin
     at the source since we're interested in identifying the FIRST
     obstruction along the path between source and destination. */
    
    for (x=2, block=0; x<path.length && block==0; x++)
    {
        distance=5280.0*path.distance[x];
        
        test_alt=sr.earthradius+(path.elevation[x]==0.0?path.elevation[x]:path.elevation[x]+sr.clutter);
        
        cos_test_angle=((source_alt2)+(distance*distance)-(test_alt*test_alt))/(2.0*source_alt*distance);
        
        /* Compare these two angles to determine if
         an obstruction exists.  Since we're comparing
         the cosines of these angles rather than
         the angles themselves, the sense of the
         following "if" statement is reversed from
         what it would be if the angles themselves
         were compared. */
        
        if (cos_xmtr_angle>=cos_test_angle)
        {
            block=1;
            first_obstruction_angle=((acos(cos_test_angle))/DEG2RAD)-90.0;
        }
    }
    
    if (block)
        elevation=first_obstruction_angle;
    
    else
        elevation=((acos(cos_xmtr_angle))/DEG2RAD)-90.0;
    
    //	path=temp;
    
    return elevation;
}

double ElevationMap::AverageTerrain(const Site &source, double azimuthx, double start_distance, double end_distance) const
{
    /* This function returns the average terrain calculated in
     the direction of "azimuth" (degrees) between "start_distance"
     and "end_distance" (miles) from the source location.  If
     the terrain is all water (non-critical error), -5000.0 is
     returned.  If not enough SDF data has been loaded into
     memory to complete the survey (critical error), then
     -9999.0 is returned. */
    
    int	c, samples, endpoint;
    double	beta, lat1, lon1, lat2, lon2, num, den, azimuth, terrain=0.0;
    Site destination;
    
    lat1=source.lat*DEG2RAD;
    lon1=source.lon*DEG2RAD;
    
    /* Generate a path of elevations between the source
     location and the remote location provided. */
    
    beta=end_distance/3959.0;
    
    azimuth=DEG2RAD*azimuthx;
    
    lat2=asin(sin(lat1)*cos(beta)+cos(azimuth)*sin(beta)*cos(lat1));
    num=cos(beta)-(sin(lat1)*sin(lat2));
    den=cos(lat1)*cos(lat2);
    
    if (azimuth==0.0 && (beta>HALFPI-lat1))
        lon2=lon1+PI;
    
    else if (azimuth==HALFPI && (beta>HALFPI+lat1))
        lon2=lon1+PI;
    
    else if (fabs(num/den)>1.0)
        lon2=lon1;
    
    else
    {
        if ((PI-azimuth)>=0.0)
            lon2=lon1-Utilities::arccos(num,den);
        else
            lon2=lon1+Utilities::arccos(num,den);
    }
    
    while (lon2<0.0)
        lon2+=TWOPI;
    
    while (lon2>TWOPI)
        lon2-=TWOPI;
    
    lat2=lat2/DEG2RAD;
    lon2=lon2/DEG2RAD;
    
    destination.lat=lat2;
    destination.lon=lon2;
    
    /* If SDF data is missing for the endpoint of
     the radial, then the average terrain cannot
     be accurately calculated.  Return -9999.0 */
    
    if (GetElevation(destination)<-4999.0)
        return (-9999.0);
    else
    {
        path.ReadPath(source,destination, *this);
        
        endpoint=path.length;
        
        /* Shrink the length of the radial if the
         outermost portion is not over U.S. land. */
        
        for (c=endpoint-1; c>=0 && path.elevation[c]==0.0; c--);
        
        endpoint=c+1;
        
        for (c=0, samples=0; c<endpoint; c++)
        {
            if (path.distance[c]>=start_distance)
            {
                terrain+=(path.elevation[c]==0.0?path.elevation[c]:path.elevation[c]+sr.clutter);
                samples++;
            }
        }
        
        if (samples==0)
            terrain=-5000.0;  /* No land */
        else
            terrain=(terrain/(double)samples);
        
        return terrain;
    }
}

double ElevationMap::haat(const Site &antenna) const
{
    /* This function returns the antenna's Height Above Average
     Terrain (HAAT) based on FCC Part 73.313(d).  If a critical
     error occurs, such as a lack of SDF data to complete the
     survey, -5000.0 is returned. */
    
    int	azi, c;
    char	error=0;
    double	terrain, avg_terrain, haat, sum=0.0;
    
    /* Calculate the average terrain between 2 and 10 miles
     from the antenna site at azimuths of 0, 45, 90, 135,
     180, 225, 270, and 315 degrees. */
    
    for (c=0, azi=0; azi<=315 && error==0; azi+=45)
    {
        terrain=AverageTerrain(antenna, (double)azi, 2.0, 10.0);
        
        if (terrain<-9998.0)  /* SDF data is missing */
            error=1;
        
        if (terrain>-4999.0)  /* It's land, not water */
        {
            sum+=terrain;  /* Sum of averages */
            c++;
        }
    }
    
    if (error)
        return -5000.0;
    else
    {
        avg_terrain=(sum/(double)c);
        haat=(antenna.alt+GetElevation(antenna))-avg_terrain;
        return haat;
    }
}

void ElevationMap::PlaceMarker(const Site &location)
{
    /* This function places text and marker data in the mask array
     for illustration on topographic maps generated by SPLAT!.
     By default, SPLAT! centers text information BELOW the marker,
     but may move it above, to the left, or to the right of the
     marker depending on how much room is available on the map,
     or depending on whether the area is already occupied by
     another marker or label.  If no room or clear space is
     available on the map to place the marker and its associated
     text, then the marker and text are not written to the map. */
    
    int	a, b, c, byte;
    char	ok2print, occupied;
    double	x, y, lat, lon, textx=0.0, texty=0.0, xmin, xmax,
    ymin, ymax, p1, p3, p6, p8, p12, p16, p24, label_length;
    
    xmin=(double)min_north;
    xmax=(double)max_north;
    ymin=(double)min_west;
    ymax=(double)max_west;
    lat=location.lat;
    lon=location.lon;
    
    if (lat<xmax && lat>=xmin && (Utilities::LonDiff(lon,ymax)<=0.0) && (Utilities::LonDiff(lon,ymin)>=sr.dpp))
    {
        p1=1.0/sr.ippd;
        p3=3.0/sr.ippd;
        p6=6.0/sr.ippd;
        p8=8.0/sr.ippd;
        p12=12.0/sr.ippd;
        p16=16.0/sr.ippd;
        p24=24.0/sr.ippd;
        
        ok2print=0;
        occupied=0;
        
        /* Is Marker Position Clear Of Text Or Other Markers? */
        
        for (a=0, x=lat-p3; (x<=xmax && x>=xmin && a<7); x+=p1, a++)
            for (b=0, y=lon-p3; (Utilities::LonDiff(y,ymax)<=0.0) && (Utilities::LonDiff(y,ymin)>=sr.dpp) && b<7; y+=p1, b++)
                occupied|=(GetMask(x,y)&2);
        
        if (occupied==0)
        {
            /* Determine Where Text Can Be Positioned */
            
            /* label_length=length in pixels.
             Each character is 8 pixels wide. */
            
            label_length=p1*(double)(location.name.size()<<3);
            
            if ((Utilities::LonDiff(lon+label_length,ymax)<=0.0) && (Utilities::LonDiff(lon-label_length,ymin)>=sr.dpp))
            {
                /* Default: Centered Text */
                
                texty=lon+label_length/2.0;
                
                if ((lat-p8)>=p16)
                {
                    /* Position Text Below The Marker */
                    
                    textx=lat-p8;
                    
                    x=textx;
                    y=texty;
                    
                    /* Is This Position Clear Of
                     Text Or Other Markers? */
                    
                    for (a=0, occupied=0; a<16; a++)
                    {
                        for (b=0; b<(int)location.name.size(); b++)
                            for (c=0; c<8; c++, y-=p1)
                                occupied|=(GetMask(x,y)&2);
                        x-=p1;
                        y=texty;
                    }
                    
                    x=textx;
                    y=texty;
                    
                    if (occupied==0)
                        ok2print=1;
                }
                
                else
                {
                    /* Position Text Above The Marker */
                    
                    textx=lat+p24;
                    
                    x=textx;
                    y=texty;
                    
                    /* Is This Position Clear Of
                     Text Or Other Markers? */
                    
                    for (a=0, occupied=0; a<16; a++)
                    {
                        for (b=0; b<(int)location.name.size(); b++)
                            for (c=0; c<8; c++, y-=p1)
                                occupied|=(GetMask(x,y)&2);
                        x-=p1;
                        y=texty;
                    }
                    
                    x=textx;
                    y=texty;
                    
                    if (occupied==0)
                        ok2print=1;
                }
            }
            
            if (ok2print==0)
            {
                if (Utilities::LonDiff(lon-label_length,ymin)>=sr.dpp)
                {
                    /* Position Text To The
                     Right Of The Marker */
                    
                    textx=lat+p6;
                    texty=lon-p12;
                    
                    x=textx;
                    y=texty;
                    
                    /* Is This Position Clear Of
                     Text Or Other Markers? */
                    
                    for (a=0, occupied=0; a<16; a++)
                    {
                        for (b=0; b<(int)location.name.size(); b++)
                            for (c=0; c<8; c++, y-=p1)
                                occupied|=(GetMask(x,y)&2);
                        x-=p1;
                        y=texty;
                    }
                    
                    x=textx;
                    y=texty;
                    
                    if (occupied==0)
                        ok2print=1;
                }
                
                else
                {
                    /* Position Text To The
                     Left Of The Marker */
                    
                    textx=lat+p6;
                    texty=lon+p8+(label_length);
                    
                    x=textx;
                    y=texty;
                    
                    /* Is This Position Clear Of
                     Text Or Other Markers? */
                    
                    for (a=0, occupied=0; a<16; a++)
                    {
                        for (b=0; b<(int)location.name.size(); b++)
                            for (c=0; c<8; c++, y-=p1)
                                occupied|=(GetMask(x,y)&2);
                        x-=p1;
                        y=texty;
                    }
                    
                    x=textx;
                    y=texty;
                    
                    if (occupied==0)
                        ok2print=1;
                }
            }
            
            /* textx and texty contain the latitude and longitude
             coordinates that describe the placement of the text
             on the map. */
            
            if (ok2print)
            {
                /* Draw Text */
                
                x=textx;
                y=texty;
                
                for (a=0; a<16; a++)
                {
                    for (b=0; b<(int)location.name.size(); b++)
                    {
                        byte=fontdata[16*(location.name[b])+a];
                        
                        for (c=128; c>0; c=c>>1, y-=p1)
                            if (byte&c)
                                OrMask(x,y,2);
                    }
                    
                    x-=p1;
                    y=texty;
                }
                
                /* Draw Square Marker Centered
                 On Location Specified */
                
                for (a=0, x=lat-p3; (x<=xmax && x>=xmin && a<7); x+=p1, a++)
                    for (b=0, y=lon-p3; (Utilities::LonDiff(y,ymax)<=0.0) && (Utilities::LonDiff(y,ymin)>=sr.dpp) && b<7; y+=p1, b++)
                        OrMask(x,y,2);
            }
        }
    }
}

void ElevationMap::PlotPath(const Site &source, const Site &destination, char mask_value)
{
    /* This function analyzes the path between the source and
     destination locations.  It determines which points along
     the path have line-of-sight visibility to the source.
     Points along with path having line-of-sight visibility
     to the source at an AGL altitude equal to that of the
     destination location are stored by setting bit 1 in the
     mask[][] array, which are displayed in green when PPM
     maps are later generated by SPLAT!. */
    
    char block;
    int x, y;
    double cos_xmtr_angle, cos_test_angle, test_alt;
    double distance, rx_alt, tx_alt;
    
    path.ReadPath(source,destination, *this);
    
    for (y=0; y<path.length; y++)
    {
        /* Test this point only if it hasn't been already
         tested and found to be free of obstructions. */
        
        if ((GetMask(path.lat[y],path.lon[y])&mask_value)==0)
        {
            distance=5280.0*path.distance[y];
            tx_alt=sr.earthradius+source.alt+path.elevation[0];
            rx_alt=sr.earthradius+destination.alt+path.elevation[y];
            
            /* Calculate the cosine of the elevation of the
             transmitter as seen at the temp rx point. */
            
            cos_xmtr_angle=((rx_alt*rx_alt)+(distance*distance)-(tx_alt*tx_alt))/(2.0*rx_alt*distance);
            
            for (x=y, block=0; x>=0 && block==0; x--)
            {
                distance=5280.0*(path.distance[y]-path.distance[x]);
                test_alt=sr.earthradius+(path.elevation[x]==0.0?path.elevation[x]:path.elevation[x]+sr.clutter);
                
                cos_test_angle=((rx_alt*rx_alt)+(distance*distance)-(test_alt*test_alt))/(2.0*rx_alt*distance);
                
                /* Compare these two angles to determine if
                 an obstruction exists.  Since we're comparing
                 the cosines of these angles rather than
                 the angles themselves, the following "if"
                 statement is reversed from what it would
                 be if the actual angles were compared. */
                
                if (cos_xmtr_angle>=cos_test_angle)
                    block=1;
            }
            
            if (block==0)
                OrMask(path.lat[y],path.lon[y],mask_value);
        }
    }
}

void ElevationMap::PlotLOSMap(const Site &source, double altitude)
{
    /* This function performs a 360 degree sweep around the
     transmitter site (source location), and plots the
     line-of-sight coverage of the transmitter on the SPLAT!
     generated topographic map based on a receiver located
     at the specified altitude (in feet AGL).  Results
     are stored in memory, and written out in the form
     of a topographic map when the WritePPM() function
     is later invoked. */
    
    int y, z, count;
    Site edge;
    unsigned char symbol[4], x;
    double lat, lon, minwest, maxnorth, th;
    static unsigned char mask_value=1;
    
    symbol[0]='.';
    symbol[1]='o';
    symbol[2]='O';
    symbol[3]='o';
    
    count=0;
    
    fprintf(stdout,"\nComputing line-of-sight coverage of \"%s\" with an RX antenna\nat %.2f %s AGL",source.name.c_str(),sr.metric?altitude*METERS_PER_FOOT:altitude,sr.metric?"meters":"feet");
    
    if (sr.clutter>0.0)
        fprintf(stdout," and %.2f %s of ground sr.clutter",sr.metric?sr.clutter*METERS_PER_FOOT:sr.clutter,sr.metric?"meters":"feet");
    
    fprintf(stdout,"...\n\n 0%c to  25%c ",37,37);
    fflush(stdout);
    
    /* th=pixels/degree divided by 64 loops per
     progress indicator symbol (.oOo) printed. */
    
    th=sr.ppd/64.0;
    
    z=(int)(th*Utilities::ReduceAngle(max_west-min_west));
    
    minwest=sr.dpp+(double)min_west;
    maxnorth=(double)max_north-sr.dpp;
    
    for (lon=minwest, x=0, y=0; (Utilities::LonDiff(lon,(double)max_west)<=0.0); y++, lon=minwest+(sr.dpp*(double)y))
    {
        if (lon>=360.0)
            lon-=360.0;
        
        edge.lat=max_north;
        edge.lon=lon;
        edge.alt=altitude;
        
        PlotPath(source,edge,mask_value);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    count=0;
    fprintf(stdout,"\n25%c to  50%c ",37,37);
    fflush(stdout);
    
    z=(int)(th*(double)(max_north-min_north));
    
    for (lat=maxnorth, x=0, y=0; lat>=(double)min_north; y++, lat=maxnorth-(sr.dpp*(double)y))
    {
        edge.lat=lat;
        edge.lon=min_west;
        edge.alt=altitude;
        
        PlotPath(source,edge,mask_value);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    count=0;
    fprintf(stdout,"\n50%c to  75%c ",37,37);
    fflush(stdout);
    
    z=(int)(th*Utilities::ReduceAngle(max_west-min_west));
    
    for (lon=minwest, x=0, y=0; (Utilities::LonDiff(lon,(double)max_west)<=0.0); y++, lon=minwest+(sr.dpp*(double)y))
    {
        if (lon>=360.0)
            lon-=360.0;
        
        edge.lat=min_north;
        edge.lon=lon;
        edge.alt=altitude;
        
        PlotPath(source,edge,mask_value);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    count=0;
    fprintf(stdout,"\n75%c to 100%c ",37,37);
    fflush(stdout);
    
    z=(int)(th*(double)(max_north-min_north));
    
    for (lat=(double)min_north, x=0, y=0; lat<(double)max_north; y++, lat=(double)min_north+(sr.dpp*(double)y))
    {
        edge.lat=lat;
        edge.lon=max_west;
        edge.alt=altitude;
        
        PlotPath(source,edge,mask_value);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    fprintf(stdout,"\nDone!\n");
    fflush(stdout);
    
    /* Assign next mask value */
    
    switch (mask_value)
    {
        case 1:
            mask_value=8;
            break;
            
        case 8:
            mask_value=16;
            break;
            
        case 16:
            mask_value=32;
    }
}

void ElevationMap::PlotLRMap(const Site &source, double altitude, const string &plo_filename, double elev[], const PatFile &pat, const Lrp &lrp)
{
    /* This function performs a 360 degree sweep around the
     transmitter site (source location), and plots the
     Irregular Terrain Model attenuation on the SPLAT!
     generated topographic map based on a receiver located
     at the specified altitude (in feet AGL).  Results
     are stored in memory, and written out in the form
     of a topographic map when the WritePPMLR() or
     WritePPMSS() functions are later invoked. */
    
    int y, z, count;
    Site edge;
    double lat, lon, minwest, maxnorth, th;
    unsigned char x, symbol[4];
    static unsigned char mask_value=1;
    FILE *fd=NULL;
    
    minwest=sr.dpp+(double)min_west;
    maxnorth=(double)max_north-sr.dpp;
    
    symbol[0]='.';
    symbol[1]='o';
    symbol[2]='O';
    symbol[3]='o';
    
    count=0;
    
    if (sr.olditm)
        fprintf(stdout,"\nComputing ITM ");
    else
        fprintf(stdout,"\nComputing ITWOM ");
    
    if (lrp.erp==0.0)
        fprintf(stdout,"path loss");
    else
    {
        if (sr.dbm)
            fprintf(stdout,"signal power level");
        else
            fprintf(stdout,"field strength");
    }
    
    fprintf(stdout," contours of \"%s\"\nout to a radius of %.2f %s with an RX antenna at %.2f %s AGL",source.name.c_str(),sr.metric?sr.max_range*KM_PER_MILE:sr.max_range,sr.metric?"kilometers":"miles",sr.metric?altitude*METERS_PER_FOOT:altitude,sr.metric?"meters":"feet");
    
    if (sr.clutter>0.0)
        fprintf(stdout,"\nand %.2f %s of ground sr.clutter",sr.metric?sr.clutter*METERS_PER_FOOT:sr.clutter,sr.metric?"meters":"feet");
    
    fprintf(stdout,"...\n\n 0%c to  25%c ",37,37);
    fflush(stdout);
    
    if (plo_filename[0]!=0)
        fd=fopen(plo_filename.c_str(),"wb");
    
    if (fd!=NULL)
    {
        /* Write header information to output file */
        
        fprintf(fd,"%d, %d\t; max_west, min_west\n%d, %d\t; max_north, min_north\n",max_west, min_west, max_north, min_north);
    }
    
    /* th=pixels/degree divided by 64 loops per
     progress indicator symbol (.oOo) printed. */
    
    th=sr.ppd/64.0;
    
    z=(int)(th*Utilities::ReduceAngle(max_west-min_west));
    
    for (lon=minwest, x=0, y=0; (Utilities::LonDiff(lon,(double)max_west)<=0.0); y++, lon=minwest+(sr.dpp*(double)y))
    {
        if (lon>=360.0)
            lon-=360.0;
        
        edge.lat=max_north;
        edge.lon=lon;
        edge.alt=altitude;
        
        PlotLRPath(source,edge,mask_value,fd,elev, pat, lrp);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    count=0;
    fprintf(stdout,"\n25%c to  50%c ",37,37);
    fflush(stdout);
    
    z=(int)(th*(double)(max_north-min_north));
    
    for (lat=maxnorth, x=0, y=0; lat>=(double)min_north; y++, lat=maxnorth-(sr.dpp*(double)y))
    {
        edge.lat=lat;
        edge.lon=min_west;
        edge.alt=altitude;
        
        PlotLRPath(source,edge,mask_value,fd,elev, pat, lrp);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    count=0;
    fprintf(stdout,"\n50%c to  75%c ",37,37);
    fflush(stdout);
    
    z=(int)(th*Utilities::ReduceAngle(max_west-min_west));
    
    for (lon=minwest, x=0, y=0; (Utilities::LonDiff(lon,(double)max_west)<=0.0); y++, lon=minwest+(sr.dpp*(double)y))
    {
        if (lon>=360.0)
            lon-=360.0;
        
        edge.lat=min_north;
        edge.lon=lon;
        edge.alt=altitude;
        
        PlotLRPath(source,edge,mask_value,fd,elev, pat, lrp);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    count=0;
    fprintf(stdout,"\n75%c to 100%c ",37,37);
    fflush(stdout);
    
    z=(int)(th*(double)(max_north-min_north));
    
    for (lat=(double)min_north, x=0, y=0; lat<(double)max_north; y++, lat=(double)min_north+(sr.dpp*(double)y))
    {
        edge.lat=lat;
        edge.lon=max_west;
        edge.alt=altitude;
        
        PlotLRPath(source,edge,mask_value,fd,elev, pat, lrp);
        count++;
        
        if (count==z)
        {
            fprintf(stdout,"%c",symbol[x]);
            fflush(stdout);
            count=0;
            
            if (x==3)
                x=0;
            else
                x++;
        }
    }
    
    if (fd!=NULL)
        fclose(fd);
    
    fprintf(stdout,"\nDone!\n");
    fflush(stdout);
    
    if (mask_value<30)
        mask_value++;
}

void ElevationMap::PlotLRPath(const Site &source, const Site &destination, unsigned char mask_value, FILE *fd, double elev[], const PatFile &pat, const Lrp &lrp)
{
    /* This function plots the RF path loss between source and
     destination points based on the ITWOM propagation model,
     taking into account antenna pattern data, if available. */
    
    int	x, y, ifs, ofs, errnum;
    char	block=0, strmode[100];
    double	loss, azimuth, pattern=0.0, xmtr_alt,
    dest_alt, xmtr_alt2, dest_alt2, cos_rcvr_angle,
    cos_test_angle=0.0, test_alt, elevation=0.0,
    distance=0.0, four_thirds_earth, rxp, dBm,
    field_strength=0.0;
    Site temp;
    
    path.ReadPath(source,destination, *this);
    
    four_thirds_earth=FOUR_THIRDS*sr.earthradius;
    
    /* Copy elevations plus sr.clutter along path into the elev[] array. */
    
    for (x=1; x<path.length-1; x++)
        elev[x+2]=(path.elevation[x]==0.0?path.elevation[x]*METERS_PER_FOOT:(sr.clutter+path.elevation[x])*METERS_PER_FOOT);
    
    /* Copy ending points without sr.clutter */
    
    elev[2]=path.elevation[0]*METERS_PER_FOOT;
    elev[path.length+1]=path.elevation[path.length-1]*METERS_PER_FOOT;
    
    /* Since the only energy the propagation model considers
     reaching the destination is based on what is scattered
     or deflected from the first obstruction along the path,
     we first need to find the location and elevation angle
     of that first obstruction (if it exists).  This is done
     using a 4/3rds Earth radius to match the radius used by
     the irregular terrain propagation model.  This information
     is required for properly integrating the antenna's elevation
     pattern into the calculation for overall path loss. */
    
    for (y=2; (y<(path.length-1) && path.distance[y]<=sr.max_range); y++)
    {
        /* Process this point only if it
         has not already been processed. */
        
        if ((GetMask(path.lat[y],path.lon[y])&248)!=(mask_value<<3))
        {
            distance=5280.0*path.distance[y];
            xmtr_alt=four_thirds_earth+source.alt+path.elevation[0];
            dest_alt=four_thirds_earth+destination.alt+path.elevation[y];
            dest_alt2=dest_alt*dest_alt;
            xmtr_alt2=xmtr_alt*xmtr_alt;
            
            /* Calculate the cosine of the elevation of
             the receiver as seen by the transmitter. */
            
            cos_rcvr_angle=((xmtr_alt2)+(distance*distance)-(dest_alt2))/(2.0*xmtr_alt*distance);
            
            if (cos_rcvr_angle>1.0)
                cos_rcvr_angle=1.0;
            
            if (cos_rcvr_angle<-1.0)
                cos_rcvr_angle=-1.0;
            
            if (pat.got_elevation_pattern || fd!=NULL)
            {
                /* Determine the elevation angle to the first obstruction
                 along the path IF elevation pattern data is available
                 or an output (.ano) file has been designated. */
                
                for (x=2, block=0; (x<y && block==0); x++)
                {
                    distance=5280.0*path.distance[x];
                    
                    test_alt=four_thirds_earth+(path.elevation[x]==0.0?path.elevation[x]:path.elevation[x]+sr.clutter);
                    
                    /* Calculate the cosine of the elevation
                     angle of the terrain (test point)
                     as seen by the transmitter. */
                    
                    cos_test_angle=((xmtr_alt2)+(distance*distance)-(test_alt*test_alt))/(2.0*xmtr_alt*distance);
                    
                    if (cos_test_angle>1.0)
                        cos_test_angle=1.0;
                    
                    if (cos_test_angle<-1.0)
                        cos_test_angle=-1.0;
                    
                    /* Compare these two angles to determine if
                     an obstruction exists.  Since we're comparing
                     the cosines of these angles rather than
                     the angles themselves, the sense of the
                     following "if" statement is reversed from
                     what it would be if the angles themselves
                     were compared. */
                    
                    if (cos_rcvr_angle>=cos_test_angle)
                        block=1;
                }
                
                if (block)
                    elevation=((acos(cos_test_angle))/DEG2RAD)-90.0;
                else
                    elevation=((acos(cos_rcvr_angle))/DEG2RAD)-90.0;
            }
            
            /* Determine attenuation for each point along
             the path using ITWOM's point_to_point mode
             starting at y=2 (number_of_points = 1), the
             shortest distance terrain can play a role in
             path loss. */
            
            elev[0]=y-1;  /* (number of points - 1) */
            
            /* Distance between elevation samples */
            
            elev[1]=METERS_PER_MILE*(path.distance[y]-path.distance[y-1]);
            
            if (sr.olditm)
                point_to_point_ITM(elev,source.alt*METERS_PER_FOOT,
                                   destination.alt*METERS_PER_FOOT, lrp.eps_dielect,
                                   lrp.sgm_conductivity, lrp.eno_ns_surfref, lrp.frq_mhz,
                                   lrp.radio_climate, lrp.pol, lrp.conf, lrp.rel, loss,
                                   strmode, errnum);
            
            else
                point_to_point(elev,source.alt*METERS_PER_FOOT,
                               destination.alt*METERS_PER_FOOT, lrp.eps_dielect,
                               lrp.sgm_conductivity, lrp.eno_ns_surfref, lrp.frq_mhz,
                               lrp.radio_climate, lrp.pol, lrp.conf, lrp.rel, loss,
                               strmode, errnum);
            
            temp.lat=path.lat[y];
            temp.lon=path.lon[y];
            
            azimuth=(source.Azimuth(temp));
            
            if (fd!=NULL)
                fprintf(fd,"%.7f, %.7f, %.3f, %.3f, ",path.lat[y], path.lon[y], azimuth, elevation);
            
            /* If ERP==0, write path loss to alphanumeric
             output file.  Otherwise, write field strength
             or received power level (below), as appropriate. */
            
            if (fd!=NULL && lrp.erp==0.0)
                fprintf(fd,"%.2f",loss);
            
            /* Integrate the antenna's radiation
             pattern into the overall path loss. */
            
            x=(int)rint(10.0*(10.0-elevation));
            
            if (x>=0 && x<=1000)
            {
                azimuth=rint(azimuth);
                
                pattern=(double)pat.antenna_pattern[(int)azimuth][x];
                
                if (pattern!=0.0)
                {
                    pattern=20.0*log10(pattern);
                    loss-=pattern;
                }
            }
            
            if (lrp.erp!=0.0)
            {
                if (sr.dbm)
                {
                    /* dBm is based on EIRP (ERP + 2.14) */
                    
                    rxp=lrp.erp/(pow(10.0,(loss-2.14)/10.0));
                    
                    dBm=10.0*(log10(rxp*1000.0));
                    
                    if (fd!=NULL)
                        fprintf(fd,"%.3f",dBm);
                    
                    /* Scale roughly between 0 and 255 */
                    
                    ifs=200+(int)rint(dBm);
                    
                    if (ifs<0)
                        ifs=0;
                    
                    if (ifs>255)
                        ifs=255;
                    
                    ofs=GetSignal(path.lat[y],path.lon[y]);
                    
                    if (ofs>ifs)
                        ifs=ofs;
                    
                    PutSignal(path.lat[y],path.lon[y],(unsigned char)ifs);
                }
                
                else
                {
                    field_strength=(139.4+(20.0*log10(lrp.frq_mhz))-loss)+(10.0*log10(lrp.erp/1000.0));
                    
                    ifs=100+(int)rint(field_strength);
                    
                    if (ifs<0)
                        ifs=0;
                    
                    if (ifs>255)
                        ifs=255;
                    
                    ofs=GetSignal(path.lat[y],path.lon[y]);
                    
                    if (ofs>ifs)
                        ifs=ofs;
                    
                    PutSignal(path.lat[y],path.lon[y],(unsigned char)ifs);
                    
                    if (fd!=NULL)
                        fprintf(fd,"%.3f",field_strength);
                }
            }
            
            else
            {
                if (loss>255)
                    ifs=255;
                else
                    ifs=(int)rint(loss);
                
                ofs=GetSignal(path.lat[y],path.lon[y]);
                
                if (ofs<ifs && ofs!=0)
                    ifs=ofs;
                
                PutSignal(path.lat[y],path.lon[y],(unsigned char)ifs);
            }
            
            if (fd!=NULL)
            {
                if (block)
                    fprintf(fd," *");
                
                fprintf(fd,"\n");
            }
            
            /* Mark this point as having been analyzed */
            
            PutMask(path.lat[y],path.lon[y],(GetMask(path.lat[y],path.lon[y])&7)+(mask_value<<3));
        }
    }
}

void ElevationMap::LoadTopoData(int max_lon, int min_lon, int max_lat, int min_lat, Sdf &sdf)
{
    /* This function loads the SDF files required
     to cover the limits of the region specified. */ 
    
    int x, y, width, ymin, ymax;
    char	string[255];
    
    width=Utilities::ReduceAngle(max_lon-min_lon);
    
    if ((max_lon-min_lon)<=180.0)
    {
        for (y=0; y<=width; y++)
            for (x=min_lat; x<=max_lat; x++)
            {
                ymin=(int)(min_lon+(double)y);
                
                while (ymin<0)
                    ymin+=360;
                
                while (ymin>=360)
                    ymin-=360;
                
                ymax=ymin+1;
                
                while (ymax<0)
                    ymax+=360;
                
                while (ymax>=360)
                    ymax-=360;
                
                if (sr.ippd==3600)
                    snprintf(string,19,"%d:%d:%d:%d-hd",x, x+1, ymin, ymax);
                else
                    snprintf(string,16,"%d:%d:%d:%d",x, x+1, ymin, ymax);
                sdf.LoadSDF(string, *this);
            }
    }
    
    else
    {
        for (y=0; y<=width; y++)
            for (x=min_lat; x<=max_lat; x++)
            {
                ymin=max_lon+y;
                
                while (ymin<0)
                    ymin+=360;
                
                while (ymin>=360)
                    ymin-=360;
                
                ymax=ymin+1;
                
                while (ymax<0)
                    ymax+=360;
                
                while (ymax>=360)
                    ymax-=360;
                
                if (sr.ippd==3600)
                    snprintf(string,19,"%d:%d:%d:%d-hd",x, x+1, ymin, ymax);
                else
                    snprintf(string,16,"%d:%d:%d:%d",x, x+1, ymin, ymax);
                sdf.LoadSDF(string, *this);
            }
    }
}

unsigned char ElevationMap::GetSignal(double lat, double lon) const
{
    /* This function reads the signal level (0-255) at the
     specified location that was previously written by the
     complimentary PutSignal() function. */
    
    int	x = 0, y = 0, indx;
    char	found;
    
    for (indx=0, found=0; indx<sr.maxpages && found==0;)
    {
        x=(int)rint(sr.ppd*(lat-dem[indx].min_north));
        y=sr.mpi-(int)rint(sr.ppd*(Utilities::LonDiff(dem[indx].max_west,lon)));
        
        if (x>=0 && x<=sr.mpi && y>=0 && y<=sr.mpi)
            found=1;
        else
            indx++;
    }
    
    if (found)
        return (dem[indx].signal[x * sr.ippd + y]);
    else
        return 0;
}

int ElevationMap::PutSignal(double lat, double lon, unsigned char signal)
{
    /* This function writes a signal level (0-255)
     at the specified location for later recall. */
    
    int	x = 0, y = 0, indx;
    char	found;
    
    for (indx=0, found=0; indx<sr.maxpages && found==0;)
    {
        x=(int)rint(sr.ppd*(lat-dem[indx].min_north));
        y=sr.mpi-(int)rint(sr.ppd*(Utilities::LonDiff(dem[indx].max_west,lon)));
        
        if (x>=0 && x<=sr.mpi && y>=0 && y<=sr.mpi)
            found=1;
        else
            indx++;
    }
    
    if (found)
    {
        dem[indx].signal[x * sr.ippd + y]=signal;
        return (dem[indx].signal[x * sr.ippd + y]);
    }
    
    else
        return 0;
}
